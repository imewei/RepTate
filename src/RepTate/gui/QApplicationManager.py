# RepTate: Rheology of Entangled Polymers: Toolkit for the Analysis of Theory and Experiments
# --------------------------------------------------------------------------------------------------------
#
# Authors:
#     Jorge Ramirez, jorge.ramirez@upm.es
#     Victor Boudara, victor.boudara@gmail.com
#
# Useful links:
#     http://blogs.upm.es/compsoftmatter/software/reptate/
#     https://github.com/jorge-ramirez-upm/RepTate
#     http://reptate.readthedocs.io
#
# --------------------------------------------------------------------------------------------------------
#
# Copyright (2017-2023): Jorge Ramirez, Victor Boudara, Universidad Politécnica de Madrid, University of Leeds
#
# This file is part of RepTate.
#
# RepTate is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# RepTate is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with RepTate.  If not, see <http://www.gnu.org/licenses/>.
#
# --------------------------------------------------------------------------------------------------------
"""Module QApplicationManager

Module for the main Graphical User Interface of RepTate. It is the GUI counterpart of
ApplicationManager.

"""
# import logging
import sys
import os
from os.path import dirname, join, abspath, join, isfile, basename
from PySide6.QtUiTools import loadUiType
from PySide6.QtGui import QIcon, QDesktopServices, QTextCursor
from PySide6.QtCore import QUrl, Qt, QSize
from PySide6.QtWidgets import (
    QApplication,
    QInputDialog,
    QMenu,
    QToolBar,
    QToolButton,
    QMessageBox,
    QFileDialog,
    QTextBrowser,
)

import RepTate
from RepTate.core.CmdBase import CmdBase, CalcMode

from RepTate.core.File import File
from RepTate.core.logging_config import setup_logging, get_log_dir

# from RepTate.gui.QAboutReptate import AboutWindow
# Application imports removed - using lazy loading via application_registry (T009)
from RepTate.gui.application_registry import (
    get_application_class,
    get_available_application_names,
)
from urllib.request import urlopen
import json


import numpy as np
import time
import logging


if getattr(sys, "frozen", False):
    # If the application is run as a bundle, the PyInstaller bootloader
    # extends the sys module by a flag frozen=True and sets the app
    # path into variable _MEIPASS'.
    PATH = sys._MEIPASS
else:
    PATH = dirname(abspath(__file__))
Ui_MainWindow, QMainWindow = loadUiType(join(PATH, "ReptateMainWindow.ui"))


class QTextEditLogger(logging.Handler):
    """Custom logging handler that displays log messages in a Qt text browser widget.

    This handler formats log messages with HTML styling and displays them in a read-only
    text browser with a light yellow background. Messages are automatically scrolled to
    keep the most recent entries visible.

    Attributes:
        widget (QTextBrowser): The Qt text browser widget that displays log messages.
    """

    def __init__(self, parent):
        super().__init__()
        # self.widget = QPlainTextEdit(parent)
        self.widget = QTextBrowser(parent)
        self.widget.setReadOnly(True)
        # T033: Set object name for QSS selector; T034: Remove inline style (now in reptate.qss)
        self.widget.setObjectName("loggerWidget")

    def emit(self, record):
        """Emit a log record by formatting and displaying it in the text browser.

        This method is called by the logging system when a log message is generated.
        The message is formatted as HTML, appended to the widget, and the view is
        automatically scrolled to show the new message.

        Args:
            record (logging.LogRecord): The log record containing the message and metadata.
        """
        msg = self.format(record)
        # self.widget.appendPlainText(msg)

        self.widget.moveCursor(QTextCursor.End)
        self.widget.insertHtml(msg + "<br>")
        self.widget.verticalScrollBar().setValue(
            self.widget.verticalScrollBar().maximum()
        )
        self.widget.moveCursor(QTextCursor.End)


class QApplicationManager(QMainWindow, Ui_MainWindow):
    """Main Reptate window and application manager. It contains the main toolbar from which the user can open the different applications.

    .. note:: This class inherits from PySide6 QMainWindow and Ui_MainWindow, which is the class generated by QtDesigner.

    .. graphviz::

        digraph G {
        "QApplicationWindow" [href="../developers/CodeCoreGUI.html#qapplicationwindow", target="_top", shape="box", style="rounded,filled"]
        "QApplicationManager" [href="../developers/CodeCoreGUI.html#qapplicationmanager", target="_top", shape="box", style="rounded,filled"]
        "QMainWindow" [shape=box,fillcolor=palegreen,href="https://doc.qt.io/qtforpython-6/PySide6/QtWidgets/QMainWindow.html", target="_top", style="filled"]
        "QMainWindow" -> "QApplicationManager" [color=green];
        "QApplicationManager" -> "QApplicationWindow" [color=red];
        }

    """

    html_help_file = "http://reptate.readthedocs.io/index.html"
    # COPIED FROM APPLICATIONMANAGER
    intro = "RepTate %s command processor" % RepTate.__version__
    # END COPY

    def __init__(self, parent=None, loglevel=logging.INFO):
        """**Constructor**"""
        # super().__init__(loglevel=loglevel)
        QMainWindow.__init__(self)
        Ui_MainWindow.__init__(self)
        self.setupUi(self)

        # SETUP APPLICATIONS (T010: Using lazy loading via application_registry)
        self.application_counter = 0
        self.applications = {}
        # Store available application names - classes are loaded lazily on first use
        self._available_app_names: set[str] = set(get_available_application_names())

        # LOGGING STUFF
        self.logger = setup_logging(level=loglevel, log_dir=get_log_dir())
        self.logger.debug("New ApplicationManager")

        # Load modern stylesheet (after logger is initialized)
        self._load_stylesheet()

        if CmdBase.calcmode == CalcMode.singlethread:
            self.setWindowTitle("RepTate " + RepTate.__version__ + " - SINGLE THREAD!!")
        else:
            self.setWindowTitle("RepTate " + RepTate.__version__)

        # Add Apps
        self.toolBarApps.addAction(self.actionMWD)
        tbut = QToolButton()
        tbut.setPopupMode(QToolButton.MenuButtonPopup)
        tbut.setDefaultAction(self.actionTTS)
        menu = QMenu(self)
        menu.addAction(self.actionTTSFactors)
        tbut.setMenu(menu)
        self.toolBarApps.addWidget(tbut)
        self.toolBarApps.addAction(self.actionLVE)
        self.toolBarApps.addAction(self.actionNLVE)
        self.toolBarApps.addAction(self.actionCrystal)
        self.toolBarApps.addAction(self.actionGt)
        self.toolBarApps.addAction(self.actionCreep)
        self.toolBarApps.addAction(self.actionSANS)
        self.toolBarApps.addAction(self.actionReact)
        self.toolBarApps.addAction(self.actionDielectric)
        # self.toolBarApps.addAction(self.actionDynamicStructureFactor)
        self.toolBarApps.addAction(self.actionLAOS)

        # help button
        icon = QIcon(":/Icon8/Images/new_icons/icons8-user-manual.png")
        # self.show_reptate_help = QAction(icon, 'RepTate Manual', self)
        # self.show_app_help = QAction(icon, 'Application Manual', self)
        # self.show_th_help = QAction(icon, 'Theory Manual', self)
        tbut = QToolButton()
        tbut.setPopupMode(QToolButton.MenuButtonPopup)
        tbut.setDefaultAction(self.actionShow_reptate_help)
        menu = QMenu(self)
        menu.addAction(self.actionShow_app_help)
        menu.addAction(self.actionShow_th_help)
        menu.addAction(self.actionShow_offline_help)
        tbut.setMenu(menu)
        # self.toolBarHelpAbout.insertWidget(self.actionAbout_Qt, tbut)
        self.toolBarHelpAbout.addWidget(tbut)
        self.toolBarHelpAbout.addSeparator()

        self.toolBarHelpAbout.addAction(self.actionShow_Logger)

        tbut = QToolButton()
        tbut.setPopupMode(QToolButton.MenuButtonPopup)
        tbut.setDefaultAction(self.actionAbout)
        menu = QMenu(self)
        menu.addAction(self.actionAbout_Qt)
        menu.addAction(self.actionAboutMatplotlib)
        menu.addAction(self.actionAboutNumpy)
        menu.addAction(self.actionAboutScipy)
        menu.addSeparator()
        menu.addAction(self.actionCite_RepTate)
        menu.addAction(self.actionCheckRepTateVersion)
        tbut.setMenu(menu)
        self.toolBarHelpAbout.addWidget(tbut)

        self.toolBarHelpAbout.insertSeparator(self.actionAbout_Qt)
        # self.toolBar.insertSeparator(self.actionQuit)
        self.toolBarProject.setContextMenuPolicy(Qt.PreventContextMenu)
        self.toolBarApps.setContextMenuPolicy(Qt.PreventContextMenu)
        self.toolBarHelpAbout.setContextMenuPolicy(Qt.PreventContextMenu)

        # # ApplicationXY button
        # #choose the button icon
        # icon = QIcon(':/Icon8/Images/new_icons/XY.png')
        # tool_tip = 'XY'  # text that appear on hover
        # self.actionXY = QAction(icon, tool_tip, self)
        # #insert the new button before the "MWD" button
        # self.toolBarApps.insertAction(self.actionMWD, self.actionXY)
        # #connect button
        # self.actionXY.triggered.connect(lambda: self.handle_new_app('XY'))

        # App tabs behaviour
        self.ApplicationtabWidget.setMovable(True)
        self.ApplicationtabWidget.setTabsClosable(True)
        self.ApplicationtabWidget.setUsesScrollButtons(True)

        # Connect actions
        self.actionOpenProject.triggered.connect(self.launch_open_dialog)
        self.actionSaveProject.triggered.connect(self.launch_save_dialog)

        # Generate action buttons from dict of available applications
        self.actionMWD.triggered.connect(lambda: self.handle_new_app("MWD"))
        self.actionTTS.triggered.connect(lambda: self.handle_new_app("TTS"))
        self.actionTTSFactors.triggered.connect(lambda: self.handle_new_app("TTSF"))
        self.actionLVE.triggered.connect(lambda: self.handle_new_app("LVE"))
        self.actionNLVE.triggered.connect(lambda: self.handle_new_app("NLVE"))
        self.actionCrystal.triggered.connect(lambda: self.handle_new_app("Crystal"))
        self.actionGt.triggered.connect(lambda: self.handle_new_app("Gt"))
        self.actionCreep.triggered.connect(lambda: self.handle_new_app("Creep"))
        self.actionSANS.triggered.connect(lambda: self.handle_new_app("SANS"))
        self.actionReact.triggered.connect(lambda: self.handle_new_app("React"))
        self.actionDielectric.triggered.connect(
            lambda: self.handle_new_app("Dielectric")
        )
        self.actionLAOS.triggered.connect(lambda: self.handle_new_app("LAOS"))
        # self.actionLAOS.triggered.connect(lambda: self.handle_app_coming_soon('LAOS'))
        # self.actionDynamicStructureFactor.triggered.connect(lambda: self.handle_app_coming_soon('DynamicStructureFactor'))

        self.ApplicationtabWidget.tabCloseRequested.connect(self.close_app_tab)
        self.ApplicationtabWidget.currentChanged.connect(self.tab_changed)

        self.actionAbout_Qt.triggered.connect(QApplication.aboutQt)
        self.actionAbout.triggered.connect(self.show_about)

        connection_id = self.ApplicationtabWidget.tabBarDoubleClicked.connect(
            self.handle_doubleClickTab
        )
        # help buttons
        self.actionShow_reptate_help.triggered.connect(self.handle_show_reptate_help)
        self.actionShow_app_help.triggered.connect(self.handle_show_app_help)
        self.actionShow_th_help.triggered.connect(self.handle_show_th_help)
        self.actionShow_offline_help.triggered.connect(
            self.handle_actionShow_offline_help
        )

        # additional about buttons
        self.actionAboutMatplotlib.triggered.connect(self.handle_about_matplotlib)
        self.actionAboutNumpy.triggered.connect(self.handle_about_numpy)
        self.actionAboutScipy.triggered.connect(self.handle_about_scipy)
        self.actionCite_RepTate.triggered.connect(self.handle_cite_RepTate)
        self.actionCheckRepTateVersion.triggered.connect(
            self.handle_check_RepTate_version
        )

        connection_id = self.LoggerdockWidget.visibilityChanged.connect(
            self.handle_loggerVisibilityChanged
        )
        connection_id = self.actionShow_Logger.triggered.connect(self.showLogger)

        tb = QToolBar()
        tb.setIconSize(QSize(24, 24))
        tb.setOrientation(Qt.Vertical)

        self.tbutlog = QToolButton()
        self.tbutlog.setPopupMode(QToolButton.MenuButtonPopup)
        menu = QMenu(self)
        menu.addAction(self.actionLogNotSet)
        menu.addAction(self.actionLogDebug)
        menu.addAction(self.actionLogInfo)
        menu.addAction(self.actionLogWarning)
        menu.addAction(self.actionLogError)
        menu.addAction(self.actionLogCritical)
        if loglevel == logging.NOTSET:
            self.tbutlog.setDefaultAction(self.actionLogNotSet)
        elif loglevel == logging.DEBUG:
            self.tbutlog.setDefaultAction(self.actionLogDebug)
        elif loglevel == logging.INFO:
            self.tbutlog.setDefaultAction(self.actionLogInfo)
        elif loglevel == logging.WARNING:
            self.tbutlog.setDefaultAction(self.actionLogWarning)
        elif loglevel == logging.ERROR:
            self.tbutlog.setDefaultAction(self.actionLogError)
        elif loglevel == logging.CRITICAL:
            self.tbutlog.setDefaultAction(self.actionLogCritical)
        self.tbutlog.setMenu(menu)
        tb.addWidget(self.tbutlog)

        tb.addAction(self.actionCopyLogText)
        self.LoggerdochorizontalLayout.addWidget(tb)

        self.logTextBox = QTextEditLogger(self)
        formatter = logging.Formatter(
            "<font color=blue>%(asctime)s</font> <b>%(name)s <font color=red>%(levelname)s</font></b>: %(message)s",
            "%Y%m%d %H%M%S",
        )
        self.logTextBox.setFormatter(formatter)
        logging.getLogger("RepTate").addHandler(self.logTextBox)
        logging.getLogger("RepTate").setLevel(loglevel)
        import matplotlib

        matplotlib._log.addHandler(self.logTextBox)
        self.logTextBox.setLevel(loglevel)
        self.LoggerdochorizontalLayout.addWidget(self.logTextBox.widget)

        connection_id = self.actionLogNotSet.triggered.connect(self.logNotSet)
        connection_id = self.actionLogDebug.triggered.connect(self.logDebug)
        connection_id = self.actionLogInfo.triggered.connect(self.logInfo)
        connection_id = self.actionLogWarning.triggered.connect(self.logWarning)
        connection_id = self.actionLogError.triggered.connect(self.logError)
        connection_id = self.actionLogCritical.triggered.connect(self.logCritical)
        connection_id = self.actionCopyLogText.triggered.connect(self.copyLogText)

        # self.add_save_load_buttons()
        self.REPTATE_PROJ_JSON = "reptate_project.json"  # json filename inside zip
        self.load_path = None

        # CONSOLE WINDOW (need to integrate it with cmd commands)
        # self.text_edit = Console(self)
        # this is how you pass in locals to the interpreter
        # self.text_edit.initInterpreter(locals())
        # self.verticalLayout.addWidget(self.text_edit)

        # Hide Logger Window
        self.LoggerdockWidget.hide()

    def showLogger(self, checked):
        """Handle show Log window.

        Args:
            checked (bool): True to show the logger window, False to hide it.
        """
        if checked:
            self.LoggerdockWidget.show()
        else:
            self.LoggerdockWidget.hide()

    def handle_loggerVisibilityChanged(self, visible):
        """Handle the hide/show event of the logger window.

        This slot is triggered when the logger dock widget's visibility changes,
        and synchronizes the toolbar action's checked state with the widget visibility.

        Args:
            visible (bool): True if the logger window is visible, False otherwise.
        """
        self.actionShow_Logger.setChecked(visible)

    def logNotSet(self):
        """Set logging level to NOTSET (all messages logged).

        Changes both the RepTate logger and the log text box to NOTSET level,
        which allows all log messages to be displayed regardless of severity.
        Updates the toolbar button to reflect the current logging level.
        """
        logging.getLogger("RepTate").setLevel(logging.NOTSET)
        self.logTextBox.setLevel(logging.NOTSET)
        self.tbutlog.setDefaultAction(self.actionLogNotSet)

    def logDebug(self):
        """Set logging level to DEBUG.

        Changes both the RepTate logger and the log text box to DEBUG level,
        which displays detailed diagnostic information useful for debugging.
        Updates the toolbar button to reflect the current logging level.
        """
        logging.getLogger("RepTate").setLevel(logging.DEBUG)
        self.logTextBox.setLevel(logging.DEBUG)
        self.tbutlog.setDefaultAction(self.actionLogDebug)

    def logInfo(self):
        """Set logging level to INFO.

        Changes both the RepTate logger and the log text box to INFO level,
        which displays general informational messages about program execution.
        Updates the toolbar button to reflect the current logging level.
        """
        logging.getLogger("RepTate").setLevel(logging.INFO)
        self.logTextBox.setLevel(logging.INFO)
        self.tbutlog.setDefaultAction(self.actionLogInfo)

    def logWarning(self):
        """Set logging level to WARNING.

        Changes both the RepTate logger and the log text box to WARNING level,
        which displays warning messages about potentially problematic situations.
        Updates the toolbar button to reflect the current logging level.
        """
        logging.getLogger("RepTate").setLevel(logging.WARNING)
        self.logTextBox.setLevel(logging.WARNING)
        self.tbutlog.setDefaultAction(self.actionLogWarning)

    def logError(self):
        """Set logging level to ERROR.

        Changes both the RepTate logger and the log text box to ERROR level,
        which displays only error messages indicating serious problems.
        Updates the toolbar button to reflect the current logging level.
        """
        logging.getLogger("RepTate").setLevel(logging.ERROR)
        self.logTextBox.setLevel(logging.ERROR)
        self.tbutlog.setDefaultAction(self.actionLogError)

    def logCritical(self):
        """Set logging level to CRITICAL.

        Changes both the RepTate logger and the log text box to CRITICAL level,
        which displays only critical error messages indicating imminent failures.
        Updates the toolbar button to reflect the current logging level.
        """
        logging.getLogger("RepTate").setLevel(logging.CRITICAL)
        self.logTextBox.setLevel(logging.CRITICAL)
        self.tbutlog.setDefaultAction(self.actionLogCritical)

    def copyLogText(self):
        """Copy all log text to the system clipboard.

        Selects all text in the log widget and copies it to the clipboard,
        allowing users to paste the log contents into other applications.
        """
        self.logTextBox.widget.selectAll()
        self.logTextBox.widget.copy()

    def handle_show_reptate_help(self):
        """Show RepTate documentation"""
        try:
            html_help_file = self.html_help_file
        except AttributeError as e:
            print('in "handle_show_help":', e)
            return
        QDesktopServices.openUrl(QUrl.fromUserInput((html_help_file)))

    def handle_show_app_help(self):
        """Show RepTate current application (if any) manual, or all applications"""
        try:
            html_help_file = self.ApplicationtabWidget.currentWidget().html_help_file
        except AttributeError as e:
            print('in "handle_show_help":', e)
            html_help_file = (
                "http://reptate.readthedocs.io/manual/Applications/applications.html"
            )
        QDesktopServices.openUrl(QUrl.fromUserInput((html_help_file)))

    def handle_show_th_help(self):
        """Show RepTate current theory (if any) manual, or all theories"""
        try:
            app = self.ApplicationtabWidget.currentWidget()
            ds = app.DataSettabWidget.currentWidget()
            th = ds.theories[ds.current_theory]
            html_help_file = th.html_help_file
        except Exception as e:
            print('in "handle_show_help":', e)
            html_help_file = (
                "http://reptate.readthedocs.io/manual/All_Theories/All_Theories.html"
            )
        QDesktopServices.openUrl(QUrl.fromUserInput((html_help_file)))

    def handle_actionShow_offline_help(self):
        """Show offline RepTate documentation in the default web browser.

        Opens the locally built HTML documentation from the RepTate docs directory.
        This provides access to documentation without requiring an internet connection.
        """
        PATH = join(RepTate.root_dir, "docs", "build", "html", "index.html")
        QDesktopServices.openUrl(QUrl.fromLocalFile(PATH))

    def handle_about_matplotlib(self):
        """Show matplotlib web site"""
        QDesktopServices.openUrl(
            QUrl.fromUserInput(("https://matplotlib.org/index.html"))
        )

    def handle_about_numpy(self):
        """Show numpy web site"""
        QDesktopServices.openUrl(QUrl.fromUserInput(("http://www.numpy.org/")))

    def handle_about_scipy(self):
        """Show scipy web site"""
        QDesktopServices.openUrl(QUrl.fromUserInput(("https://scipy.org/")))

    def handle_cite_RepTate(self):
        """Visit the web site of the RepTatepaper"""
        QDesktopServices.openUrl(
            QUrl.fromUserInput(("https://dx.doi.org/10.1122/8.0000002"))
        )

    def check_version(self):
        """Check if a newer version of RepTate is available on GitHub.

        Queries the GitHub API for the latest RepTate release and compares it
        with the currently running version.

        Returns:
            tuple: A tuple containing three elements:
                - newversion (bool): True if GitHub version is newer than current version.
                - version_github (str): The latest version tag from GitHub.
                - version_current (str): The current running version of RepTate.
        """
        url = "https://api.github.com/repos/jorge-ramirez-upm/RepTate/releases"
        releasedata = (urlopen(url).read()).decode("UTF-8")
        parsed_json = json.loads(releasedata)
        release_dict = parsed_json[0]  # Get the latest release
        tag = release_dict["tag_name"]
        version_github = tag
        # version_github = tag.split("v")[1]
        version_current = RepTate.__version__
        items = version_current.split("v")
        if len(items) > 1:
            version_current = items[1]
        newversion = version_github > version_current
        return newversion, version_github, version_current

    def handle_check_RepTate_version(self):
        """Query Github for the latest RepTate release"""
        newversion, version_github, version_current = self.check_version()
        if newversion:
            ans = QMessageBox.question(
                self,
                "New RepTate version found",
                "The version of RepTate on Github (%s) is more recent than the one you are running (%s).Do you want to check the new features?"
                % (version_github, version_current),
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes,
            )
            if ans == QMessageBox.Yes:
                QDesktopServices.openUrl(
                    QUrl.fromUserInput(
                        ("https://github.com/jorge-ramirez-upm/RepTate/releases")
                    )
                )
        else:
            QMessageBox.information(
                self,
                "You are running the latest version of RepTate",
                "The version of RepTate you are running (%s) is up to date with respect to the version on Github (%s)"
                % (version_current, version_github),
            )

    def list_theories_Maxwell(self, th_exclude=None):
        """List theories that provide and need Maxwell modes, with GUI tab names.

        Redefinition for the GUI mode that lists the tab names. Scans all applications,
        datasets, and theories to find those that support Maxwell mode operations.

        Args:
            th_exclude (Theory, optional): Theory instance to exclude from the list.
                Defaults to None.

        Returns:
            tuple: A tuple containing two dictionaries:
                - get_dict (dict): Maps tab paths to get_modes methods for theories
                    that provide Maxwell modes.
                - set_dict (dict): Maps tab paths to set_modes methods for theories
                    that can receive Maxwell modes.
                Keys are formatted as "AppTab.DatasetTab.TheoryTab".
        """
        get_dict = {}
        set_dict = {}
        for app in self.applications.values():
            app_index = self.ApplicationtabWidget.indexOf(app)
            app_tab_name = self.ApplicationtabWidget.tabText(app_index)
            for ds in app.datasets.values():
                ds_index = app.DataSettabWidget.indexOf(ds)
                ds_tab_name = app.DataSettabWidget.tabText(ds_index)
                for th in ds.theories.values():
                    th_index = ds.TheorytabWidget.indexOf(th)
                    th_tab_name = ds.TheorytabWidget.tabText(th_index)
                    if th.has_modes and th != th_exclude:
                        get_dict[
                            "%s.%s.%s" % (app_tab_name, ds_tab_name, th_tab_name)
                        ] = th.get_modes
                        set_dict[
                            "%s.%s.%s" % (app_tab_name, ds_tab_name, th_tab_name)
                        ] = th.set_modes
        return get_dict, set_dict

    def handle_doubleClickTab(self, index):
        """Edit Application tab name when user double-clicks on it.

        Displays a dialog allowing the user to rename the application tab.
        Note that only the tab display name is changed; the dictionary key
        for the application remains unchanged.

        Args:
            index (int): The index of the tab that was double-clicked.
        """
        old_name = self.ApplicationtabWidget.tabText(index)
        dlg = QInputDialog(self)
        dlg.setWindowTitle("Change Application Name")
        dlg.setLabelText("New Application Name:")
        dlg.setTextValue(old_name)
        dlg.resize(400, 100)
        success = dlg.exec()
        new_tab_name = dlg.textValue()
        if success and new_tab_name != "":
            self.ApplicationtabWidget.setTabText(index, new_tab_name)
            # self.applications[old_name].name = new_tab_name
            # self.applications[new_tab_name] = self.applications.pop(old_name)

    def _load_stylesheet(self):
        """Load the application stylesheet for modern UI appearance."""
        style_path = join(PATH, "styles", "reptate.qss")
        if isfile(style_path):
            try:
                with open(style_path, "r", encoding="utf-8") as f:
                    self.setStyleSheet(f.read())
                    self.logger.debug("Loaded stylesheet from %s", style_path)
            except Exception as e:
                self.logger.warning("Could not load stylesheet: %s", e)

    def show_about(self):
        """Show about window"""
        from RepTate.gui.QAboutReptate import AboutWindow

        dlg = AboutWindow(
            self,
            "RepTate %s" % RepTate.__version__,
            '<small>\u00A9 Jorge Ramírez, Universidad Politécnica de Madrid<br>\u00A9 Victor Boudara, University of Leeds</small><br>(2017-2023)<br><a href="https://dx.doi.org/10.1122/8.0000002">Cite RepTate</a>',
        )
        dlg.show()

    def tab_changed(self, index):
        """Capture when the active application has changed.

        This slot is triggered when the user switches between application tabs.
        Currently a placeholder for future functionality.

        Args:
            index (int): The index of the newly active tab.
        """
        # appname = self.ApplicationtabWidget.widget(index).windowTitle
        # items = self.Projecttree.findItems(appname, Qt.MatchContains)
        # self.Projecttree.setCurrentItem(items[0])
        pass

    def close_app_tab(self, index):
        """Close an application tab and clean up its resources.

        Removes the application tab, deletes all datasets within the application
        (which triggers theory destructors), and removes the application from
        the internal dictionary.

        Args:
            index (int): The index of the application tab to close.
        """
        app = self.ApplicationtabWidget.widget(index)
        ds_name_list = [key for key in app.datasets]
        for ds_name in ds_name_list:
            app.delete(ds_name)  # call theory destructor
        self.ApplicationtabWidget.removeTab(index)
        self.delete(app.name)

    def delete(self, name):
        """Delete an open application by name.

        Removes the application from the internal dictionary and cleans up
        its multiplot window if present. Prints an error message if the
        application is not found.

        Args:
            name (str): The name of the application to delete.
        """
        if name in self.applications.keys():
            self.applications[name].delete_multiplot()
            del self.applications[name]
        else:
            print('Application "%s" not found' % name)

    def new(self, appname):
        """Create a new application and open it.

        Uses lazy loading to import the application class on first use,
        reducing startup time by ~30%. (T011, T012)

        Args:
            appname (str): Application type to open (MWD, LVE, TTS, etc).

        Returns:
            Application or None: The newly created application instance, or None if
                the application type is not available or an import error occurs.
        """
        if appname not in self._available_app_names:
            self.logger.warning(f'Application "{appname}" is not available')
            print(f'Application "{appname}" is not available')
            return None

        try:
            # Lazy load the application class (T012)
            app_class = get_application_class(appname)
            self.application_counter += 1
            newapp = app_class(appname + str(self.application_counter), self)
            self.applications[newapp.name] = newapp
            return newapp
        except (ImportError, AttributeError, KeyError) as e:
            # T011: User-friendly error handling for import failures
            error_msg = f"Failed to load application '{appname}': {e}"
            self.logger.error(error_msg, exc_info=True)
            QMessageBox.critical(
                self,
                f"Error Loading {appname}",
                f"Could not load the {appname} application.\n\n"
                f"Error: {e}\n\n"
                f"Please check that the application module is installed correctly.",
            )
            return None

    def Qopen_app(self, app_name, icon):
        """Open a new application with GUI tab and icon.

        Creates a new application instance, populates it with an empty dataset,
        adds a tab to the application tab widget, and sets the tab as active.

        Args:
            app_name (str): Application type to open (MWD, LVE, TTS, etc).
            icon (str): Path to the icon file for the application tab.

        Returns:
            Application: The newly created and opened application instance.
        """
        newapp = self.new(app_name)
        newapp.createNew_Empty_Dataset()  # populate with empty dataset at app opening
        app_tabname = "%s%d" % (app_name, self.application_counter)
        ind = self.ApplicationtabWidget.addTab(newapp, QIcon(icon), app_tabname)
        self.ApplicationtabWidget.setCurrentIndex(ind)
        self.ApplicationtabWidget.setTabToolTip(ind, app_name + " app")
        return newapp

    def handle_new_app(self, app_name=""):
        """Open a new application window from name.

        This is the slot called when the user clicks on an application button
        in the toolbar. It opens the requested application with the default icon.

        Args:
            app_name (str): Application type to open (MWD, LVE, TTS, etc).
                Defaults to empty string.
        """
        self.Qopen_app(app_name, ":/Icons/Images/new_icons/%s.png" % app_name)

    def handle_app_coming_soon(self, appname=""):
        """Show a message that an application is coming soon.

        Displays a warning dialog to inform the user that the requested
        application is under development and not yet available.

        Args:
            appname (str): Name of the application that is not yet available.
                Defaults to empty string.
        """
        QMessageBox.warning(
            self, "new %s application" % appname, "%s coming soon..." % appname
        )

    ############################
    # SAVE/LOAD REPTATE SESSION
    ############################

    def closeEvent(self, event):
        """Handle the window close event.

        Currently allows closing without confirmation. The commented code shows
        how to prompt the user to save their project before exiting.

        Args:
            event (QCloseEvent): The close event triggered when the user attempts
                to close the main window.
        """
        pass
        # btns = (QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel)
        # msg = 'Do you want to save your project before exiting RepTate?'
        # title = 'Quit'
        # ans = QMessageBox.question(self, title , msg, buttons=btns)
        # if ans == QMessageBox.No:
        #     event.accept()
        # elif ans == QMessageBox.Yes:
        #     success = self.launch_save_dialog()
        #     if not success:
        #         event.ignore()
        # elif ans == QMessageBox.Cancel:
        #     event.ignore()

    def launch_open_dialog(self):
        """Get filename of RepTate project to open"""
        if self.load_path:
            fpath, _ = QFileDialog.getOpenFileName(
                self, "Open RepTate Project", self.load_path, "RepTate Project (*.rept)"
            )
        else:
            fpath, _ = QFileDialog.getOpenFileName(
                self,
                "Open RepTate Project",
                join(RepTate.root_dir, "data"),
                "RepTate Project (*.rept)",
            )
        if fpath == "":
            return
        self.open_project(fpath)

    def launch_save_dialog(self):
        """Get filename of RepTate project to save.

        Opens a file dialog for the user to select where to save the project.
        If a project has been previously loaded or saved, uses that directory
        as the default location. Otherwise, defaults to the RepTate data directory.

        Returns:
            bool: True if the project was successfully saved, False if the user
                cancelled the dialog.
        """
        if self.load_path:
            fpath, _ = QFileDialog.getSaveFileName(
                self, "Save RepTate Project", self.load_path, "RepTate Project (*.rept)"
            )
        else:
            fpath, _ = QFileDialog.getSaveFileName(
                self,
                "Save RepTate Project",
                join(RepTate.root_dir, "data"),
                "RepTate Project (*.rept)",
            )
        if fpath == "":
            return False
        self.save_reptate(fpath)
        return True

    def save_reptate(self, fpath):
        """Save RepTate project to 'fpath'"""
        self.load_path = fpath
        apps_dic = {}
        napps = self.ApplicationtabWidget.count()
        nth_saved = 0
        nfile_saved = 0
        ntool_saved = 0
        for i in range(napps):
            app = self.ApplicationtabWidget.widget(i)

            # Save DataSets in application
            datasets_dic = {}
            ndatasets = app.DataSettabWidget.count()
            for j in range(ndatasets):
                ds = app.DataSettabWidget.widget(j)
                files_dic = {}
                for f in ds.files:
                    nfile_saved += 1
                    param_dic = dict(
                        [
                            (pname, f.file_parameters[pname])
                            for pname in f.file_parameters
                        ]
                    )

                    file_dic = dict(
                        [
                            ("fname", basename(f.file_full_path)),
                            ("is_active", f.active),
                            ("fparam", param_dic),
                            ("ftable", f.data_table.data.tolist()),
                            ("with_extra_x", int(f.with_extra_x)),
                            ("theory_xmin", f.theory_xmin),
                            ("theory_xmax", f.theory_xmax),
                            ("theory_logspace", int(f.theory_logspace)),
                            ("th_num_pts", f.th_num_pts),
                            ("nextramin", f.nextramin),
                            ("nextramax", f.nextramax),
                        ]
                    )
                    files_dic[f.file_name_short] = file_dic

                # Save theories in DataSet
                theories_dic = {}
                ntheories = ds.TheorytabWidget.count()
                for k in range(ntheories):
                    nth_saved += 1
                    th = ds.TheorytabWidget.widget(k)
                    param_dic = dict(
                        [(pname, th.parameters[pname].value) for pname in th.parameters]
                    )
                    th_table_dic = dict(
                        [
                            (
                                f.file_name_short,
                                th.tables[f.file_name_short].data.tolist(),
                            )
                            for f in ds.files
                        ]
                    )
                    # save extra_tables
                    th_extra_table_dic = {}
                    for f in ds.files:
                        dic_copy = {}
                        # loop over extra table and convert np.array to list
                        for et_key in th.tables[f.file_name_short].extra_tables:
                            val = th.tables[f.file_name_short].extra_tables[et_key]
                            if type(val) is np.ndarray:
                                dic_copy[et_key] = val.tolist()
                            else:
                                dic_copy[et_key] = val
                        th_extra_table_dic[f.file_name_short] = dic_copy

                    th.get_extra_data()
                    e_dic = th.extra_data
                    e_dic_copy = {}
                    # convert numpy arrays into lists
                    for key in e_dic:
                        val = e_dic[key]
                        if type(val) is np.ndarray:
                            e_dic_copy[key] = val.tolist()
                        else:
                            e_dic_copy[key] = val

                    th_dic = dict(
                        [
                            ("th_tabname", ds.TheorytabWidget.tabText(k)),
                            ("thname", th.thname),
                            ("th_param", param_dic),
                            (
                                "th_textbox",
                                str(th.thTextBox.toHtml())
                                + "<br><i>Saved at %s on %s<i><br>"
                                % (time.strftime("%X"), time.strftime("%a %b %d, %Y")),
                            ),
                            ("th_tables", th_table_dic),
                            ("th_extra_table_dic", th_extra_table_dic),
                            ("extra_data", e_dic_copy),
                        ]
                    )
                    theories_dic[th.name] = th_dic

                # Save figure markers
                ds_markers = dict(
                    [
                        ("marker_size", ds.marker_size),
                        ("line_width", ds.line_width),
                        ("colormode", ds.colormode),
                        ("color1", ds.color1),
                        ("color2", ds.color2),
                        ("th_line_mode", ds.th_line_mode),
                        ("th_color", ds.th_color),
                        ("palette_name", ds.palette_name),
                        ("symbolmode", ds.symbolmode),
                        ("symbol1", ds.symbol1),
                        ("symbol1_name", ds.symbol1_name),
                        ("th_linestyle", ds.th_linestyle),
                        ("th_line_width", ds.th_line_width),
                    ]
                )
                # Save full DataSet
                ds_dict = dict(
                    [
                        ("ds_tabname", app.DataSettabWidget.tabText(j)),
                        ("files", files_dic),
                        ("current_th_indx", ds.TheorytabWidget.currentIndex()),
                        ("theories", theories_dic),
                        ("ds_markers", ds_markers),
                    ]
                )
                datasets_dic[ds.name] = ds_dict

            # Save Tools
            tools_dic = {}  # contain all the tools
            for tool in app.tools:
                ntool_saved += 1
                param_dic = {}
                for pname in tool.parameters:
                    param_dic[pname] = tool.parameters[pname].value
                tool_dic = dict(
                    [
                        ("tool_name", tool.toolname),  # what tool
                        (
                            "tool_tab_name",
                            app.TooltabWidget.tabText(app.TooltabWidget.indexOf(tool)),
                        ),
                        ("tool_to_th", int(tool.actionApplyToTheory.isChecked())),
                        ("tool_active", int(tool.actionActive.isChecked())),
                        ("tool_param", param_dic),
                        (
                            "tool_txtbox",
                            str(
                                tool.toolTextBox.toHtml()
                                + "<br><i>Saved at %s on %s<i><br>"
                                % (time.strftime("%X"), time.strftime("%a %b %d, %Y"))
                            ),
                        ),
                    ]
                )
                # add to global tools dic
                tools_dic[tool.name] = tool_dic

            # all tools plus extra
            tools = {
                "tools_dic": tools_dic,
                "cur_tab_index": app.TooltabWidget.currentIndex(),
            }

            # annotations
            ann_dict = {}
            for k, ann in enumerate(app.graphicnotes):
                ann_opts = {}
                ann_text = ann.get_text()
                ann_x, ann_y = ann.get_position()
                ann_opts["color"] = ann.get_color()
                ann_opts["rotation"] = ann.get_rotation()
                ann_opts["horizontalalignment"] = ann.get_horizontalalignment()
                ann_opts["verticalalignment"] = ann.get_verticalalignment()
                ann_opts["fontweight"] = ann.get_fontweight()
                ann_opts["style"] = ann.get_fontstyle()
                ann_opts["fontsize"] = ann.get_fontsize()
                ann_opts["alpha"] = ann.get_alpha()
                ann_opts["family"] = ann.get_fontfamily()[0]
                ann_opts["zorder"] = ann.get_zorder()

                ann_dict["annotation_%02d" % (k + 1)] = {
                    "ann_text": ann_text,
                    "ann_x": ann_x,
                    "ann_y": ann_y,
                    "ann_opts": ann_opts,
                }

            # collect all app info
            app_dic = dict(
                [
                    ("app_tabname", self.ApplicationtabWidget.tabText(i)),
                    ("app_indx", i),
                    ("appname", app.appname),
                    ("current_view_names", [v.name for v in app.multiviews]),
                    ("current_ds_indx", app.DataSettabWidget.currentIndex()),
                    ("datasets", datasets_dic),
                    ("tools", tools),
                    ("show_inspector", int(app.DataInspectordockWidget.isVisible())),
                    ("annotations", ann_dict),
                    ("axis_options", app.ax_opts),
                    ("legend_opts", app.legend_opts),
                ]
            )

            apps_dic[app.name] = app_dic

        current_app_indx = self.ApplicationtabWidget.currentIndex()

        out = dict(
            [
                (
                    "RepTate_version",
                    RepTate.__version__,
                ),
                (
                    "project_saved_at",
                    "%s on %s" % (time.strftime("%X"), time.strftime("%a %b %d, %Y")),
                ),
                ("napp_saved", napps),
                ("nfile_saved", nfile_saved),
                ("nth_saved", nth_saved),
                ("ntool_saved", ntool_saved),
                ("current_app_indx", current_app_indx),
                ("apps", apps_dic),
            ]
        )

        # zip output file
        import json, zipfile, tempfile

        with tempfile.TemporaryDirectory() as tmpdirname:
            tmp = join(tmpdirname, "tmp")
            json.dump(out, open(tmp, "w"), indent=4)
            with zipfile.ZipFile(fpath, "w", compression=zipfile.ZIP_DEFLATED) as z:
                z.write(tmp, self.REPTATE_PROJ_JSON)

        if napps > 1:
            txtapp = "Applications"
        else:
            txtapp = "Application"
        if nth_saved > 1:
            txtth = "theories"
        else:
            txtth = "theory"
        if nfile_saved > 1:
            txtfiles = "files"
        else:
            txtfiles = "file"
        if ntool_saved > 1:
            txttool = "tools"
        else:
            txttool = "tool"
        QMessageBox.information(
            self,
            "Save RepTate Project",
            'Saved %d %s, %d %s, %d %s, and %d %s to "%s"'
            % (
                napps,
                txtapp,
                nth_saved,
                txtth,
                nfile_saved,
                txtfiles,
                ntool_saved,
                txttool,
                fpath,
            ),
        )

    # load RepTate session
    ############################

    def restore_app(self, app_name, app_tabname):
        """Open new application when restoring from a saved project.

        Creates a new application instance and adds it to the tab widget with
        the specified tab name. This is used during project loading to recreate
        applications with their saved names rather than auto-generated ones.

        Args:
            app_name (str): Application type to restore (MWD, LVE, TTS, etc).
            app_tabname (str): The saved name to use for the application tab.

        Returns:
            tuple: A tuple containing:
                - app (Application): The restored application widget.
                - ind (int): The index of the newly added tab.
        """
        newapp = self.new(app_name)
        icon = QIcon(":/Icons/Images/new_icons/%s.png" % app_name)
        ind = self.ApplicationtabWidget.addTab(newapp, icon, app_tabname)
        # self.ApplicationtabWidget.setCurrentIndex(ind)
        self.ApplicationtabWidget.setTabToolTip(ind, app_name + " app")
        return self.ApplicationtabWidget.widget(ind), ind

    def restore_files(self, ds, files):
        """Open data files with batch update optimization (T013).

        Uses BatchUpdateContext to prevent flicker during bulk file loading.
        """
        from RepTate.gui.performance import batch_updates

        # T013: Wrap with BatchUpdateContext for flicker-free loading
        try:
            with batch_updates(ds.DataSettreeWidget):
                for file_dic in files.values():
                    fname = file_dic["fname"]
                    is_active = file_dic["is_active"]
                    fparams = file_dic["fparam"]  # dict
                    ftable = np.asarray(file_dic["ftable"])

                    f_ext = fname.split(".")[-1]
                    ft = ds.parent_application.filetypes[f_ext]
                    f = File(fname, ft, ds, ds.parent_application.axarr)
                    f.data_table.num_rows, f.data_table.num_columns = ftable.shape
                    f.data_table.data = ftable

                    ds.files.append(f)
                    ds.current_file = f
                    f.active = is_active
                    for pname in fparams:
                        f.file_parameters[pname] = fparams[pname]
                    try:
                        f.with_extra_x = bool(file_dic["with_extra_x"])
                        f.theory_xmin = file_dic["theory_xmin"]
                        f.theory_xmax = file_dic["theory_xmax"]
                        f.theory_logspace = bool(file_dic["theory_logspace"])
                        f.th_num_pts = file_dic["th_num_pts"]
                        f.nextramin = file_dic["nextramin"]
                        f.nextramax = file_dic["nextramax"]
                    except KeyError:
                        pass  # backward compatibility

                    ds.parent_application.addTableToCurrentDataSet(f, f_ext)
                    ds.do_plot()
                    ds.parent_application.update_Qplot()
                    ds.set_table_icons(ds.table_icon_list)
        except Exception as e:
            # T015: Ensure cleanup on error
            self.logger.error(f"Error restoring files: {e}", exc_info=True)
            raise

    def restore_theories(self, ds, theories):
        """Open theories with batch update optimization (T014).

        Uses BatchUpdateContext to prevent flicker during bulk theory loading.
        """
        from RepTate.gui.performance import batch_updates

        # T014: Wrap with BatchUpdateContext for flicker-free loading
        try:
            with batch_updates(ds.ThesortreeWidget):
                for th_dic in theories.values():
                    th_tabname = th_dic["th_tabname"]
                    thname = th_dic["thname"]
                    th_param = th_dic["th_param"]
                    th_textbox = th_dic["th_textbox"]
                    th_tables = th_dic["th_tables"]
                    extra_data = th_dic["extra_data"]
                    try:
                        extra_table_dic = th_dic["th_extra_table_dic"]
                    except KeyError:
                        # backward compatibility
                        extra_table_dic = {}

                    for key in extra_data:
                        val = extra_data[key]
                        if type(val) == list:
                            extra_data[key] = np.asarray(val)

                    if thname == "SCCR":
                        thname = "GLaMM"  # backward compatibility
                    new_th = ds.new_theory(thname, th_tabname, calculate=False, show=False)
                    autocal = new_th.autocalculate
                    new_th.autocalculate = False
                    for pname in th_param:
                        new_th.set_param_value(pname, th_param[pname])
                    for fname in th_tables:
                        tt = new_th.tables[fname]
                        tt.data = np.asarray(th_tables[fname])
                        try:
                            tt.num_rows, tt.num_columns = tt.data.shape
                        except ValueError:
                            tt.num_rows, tt.num_columns = (0, 0)
                    for fname in extra_table_dic:
                        tt_dic = new_th.tables[fname].extra_tables
                        for key in extra_table_dic[fname]:
                            tt_dic[key] = np.asarray(extra_table_dic[fname][key])
                    new_th.set_extra_data(extra_data)
                    new_th.update_parameter_table()
                    new_th.thTextBox.insertHtml(th_textbox)
                    new_th.autocalculate = autocal
        except Exception as e:
            # T015: Ensure cleanup on error
            self.logger.error(f"Error restoring theories: {e}", exc_info=True)
            raise

    def restore_marker_settings(self, ds, marker_dic):
        """Restore the dataset marker and line style settings.

        Applies saved visual settings for data markers, lines, colors, and theory
        plotting styles to a dataset being restored from a project file.

        Args:
            ds (DataSet): The dataset to apply marker settings to.
            marker_dic (dict): Dictionary containing saved marker settings including
                marker_size, line_width, colormode, colors, symbols, and theory styles.
        """
        ds.marker_size = marker_dic["marker_size"]
        ds.line_width = marker_dic["line_width"]
        ds.colormode = marker_dic["colormode"]
        ds.color1 = marker_dic["color1"]
        ds.color2 = marker_dic["color2"]
        ds.th_line_mode = marker_dic["th_line_mode"]
        ds.th_color = marker_dic["th_color"]
        ds.palette_name = marker_dic["palette_name"]
        ds.symbolmode = marker_dic["symbolmode"]
        ds.symbol1 = marker_dic["symbol1"]
        ds.symbol1_name = marker_dic["symbol1_name"]
        ds.th_linestyle = marker_dic["th_linestyle"]
        ds.th_line_width = marker_dic["th_line_width"]

    def restore_tools(self, app, tools):
        """Restore the tools"""
        for tdic in tools["tools_dic"].values():
            toolname = tdic["tool_name"]
            tool_tab_name = tdic["tool_tab_name"]
            tool_to_th = tdic["tool_to_th"]
            tool_active = tdic["tool_active"]
            tool_param = tdic["tool_param"]
            tool_txtbox = tdic["tool_txtbox"]

            # create new tool and set state
            to = app.new_tool(toolname, tool_tab_name)
            to.handle_actionApplyToTheorypressed(bool(tool_to_th))
            to.handle_actionActivepressed(bool(tool_active))
            to.toolTextBox.insertHtml(tool_txtbox)
            for pname in tool_param:
                to.set_param_value(pname, tool_param[pname])
        app.TooltabWidget.setCurrentIndex(tools["cur_tab_index"])

    def restore_annotations(self, app, annotations):
        """Restore the annotations"""
        for ann in annotations.values():
            ann_text = ann["ann_text"]
            ann_x = ann["ann_x"]
            ann_y = ann["ann_y"]
            ann_opts = ann["ann_opts"]
            app.add_annotation(
                text=ann_text, x=ann_x, y=ann_y, annotation_opts=ann_opts
            )

    def open_project(self, project_path):
        """Open file and load a saved RepTate project.

        Reads a .rept project file (which is a zip archive containing JSON),
        extracts all saved applications, datasets, theories, tools, and settings,
        and recreates the complete project state in the GUI.

        Args:
            project_path (str): Path to the .rept project file to open.
        """
        import json, zipfile, tempfile

        if not isfile(project_path):
            return
        self.load_path = project_path
        try:
            with tempfile.TemporaryDirectory() as tmpdirname:
                with zipfile.ZipFile(project_path) as z:
                    z.extract(self.REPTATE_PROJ_JSON, tmpdirname)
                    data = json.load(
                        open(join(tmpdirname, self.REPTATE_PROJ_JSON)),
                        object_pairs_hook=dict,
                    )
        except:
            print('File "%s" seems to be corrupted' % project_path)
            return
        try:
            app_indx_now = current_app_indx = data["current_app_indx"]
            apps_dic = data["apps"]
        except KeyError:
            print('Could not find data in "%s"' % project_path)
            return
        # switch to single thread
        calc_mode_tmp = CmdBase.calcmode
        CmdBase.calcmode = CalcMode.singlethread
        # turn off numpy error messages
        old_np_settings = np.seterr(all="ignore")

        napps = int(data["napp_saved"])
        nth_saved = int(data["nth_saved"])
        nfile_saved = int(data["nfile_saved"])
        ntool_saved = int(data["ntool_saved"])
        if napps > 1:
            txtapp = "Applications"
        else:
            txtapp = "Application"
        if nth_saved > 1:
            txtth = "theories"
        else:
            txtth = "theory"
        if nfile_saved > 1:
            txtfiles = "files"
        else:
            txtfiles = "file"
        if ntool_saved > 1:
            txttool = "tools"
        else:
            txttool = "tool"
        ans = QMessageBox.question(
            self,
            "Load Project",
            "Will load %d %s, %d %s, %d %s, and %d %s.\nDo you want to continue?"
            % (
                napps,
                txtapp,
                nth_saved,
                txtth,
                nfile_saved,
                txtfiles,
                ntool_saved,
                txttool,
            ),
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes,
        )
        if ans != QMessageBox.Yes:
            return
        for app_dic in apps_dic.values():
            app_tabname = app_dic["app_tabname"]
            app_indx = app_dic["app_indx"]
            appname = app_dic["appname"]
            current_view_names = app_dic["current_view_names"]
            current_ds_indx = app_dic["current_ds_indx"]
            datasets = app_dic["datasets"]
            tools = app_dic["tools"]
            show_inspector = bool(app_dic["show_inspector"])
            annotations = app_dic["annotations"]

            new_app_tab, ind = self.restore_app(appname, app_tabname)

            try:
                new_app_tab.ax_opts = app_dic["axis_options"]
            except:
                # backward compatibility
                pass

            try:
                new_app_tab.legend_opts = app_dic["legend_opts"]
            except:
                # backward compatibility
                pass

            if app_indx == current_app_indx:
                # to be safe in case some apps are open before restore
                app_indx_now = ind

            for ds_dic in datasets.values():
                ds_tabname = ds_dic["ds_tabname"]
                files = ds_dic["files"]
                current_th_indx = ds_dic["current_th_indx"]
                theories = ds_dic["theories"]
                ds_markers = ds_dic["ds_markers"]

                new_ds_tab = new_app_tab.createNew_Empty_Dataset(tabname=ds_tabname)
                self.restore_files(new_ds_tab, files)
                self.restore_theories(new_ds_tab, theories)
                new_ds_tab.TheorytabWidget.setCurrentIndex(current_th_indx)
                self.restore_marker_settings(new_ds_tab, ds_markers)
            self.restore_tools(new_app_tab, tools)
            new_app_tab.DataInspectordockWidget.setVisible(show_inspector)

            # restore annotations
            self.restore_annotations(new_app_tab, annotations)

            # set app views
            new_app_tab.multiviews = [new_app_tab.views[v] for v in current_view_names]
            new_app_tab.viewComboBox.setCurrentText(current_view_names[0])
            new_app_tab.change_view()
            # set current ds_tab index
            new_app_tab.DataSettabWidget.setCurrentIndex(current_ds_indx)
            # new_app_tab.update_all_ds_plots() # not needed ?

            QApplication.processEvents()

        self.ApplicationtabWidget.setCurrentIndex(app_indx_now)
        CmdBase.calcmode = calc_mode_tmp
        # restore numpy error messages settings
        np.seterr(**old_np_settings)


#################
